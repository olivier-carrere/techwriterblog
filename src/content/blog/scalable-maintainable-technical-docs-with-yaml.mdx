---
draft: false
title: "Boost Documentation Efficiency: How YAML Outperforms XML, Markdown, and Databases"
snippet: "Streamline your docs with YAML: scalable, automated, and maintainable solutions for technical data."
image:
  src: "/images/blog/scalable-maintainable-technical-docs-with-yaml.webp"
  alt: "YAML table evolving into a structured schema for documentation and APIs"
publishDate: "2025-09-27 00:00"
category: "Blog"
author: "Olivier Carrère"
tags: [YAML, OpenAPI, Schema, Structured Data, Technical Writing, Content Reuse, Validation]
---

import ToolsList from '../../components/ToolsList.astro'
import ToolsTable from '../../components/ToolsTable.astro'
import ToolsTableFourCols from '../../components/ToolsTableFourCols.astro';
import yamlRaw from '../../data/oil-types.yaml?raw';

YAML is a lightweight, human-readable data format that simplifies configuration files and data exchange. Its clarity, flexibility, and efficiency make it increasingly popular among developers, often outperforming XML, Markdown, and some database solutions in modern applications.

You can also leverage YAML for structured documentation.

## Imaginary Scenario: Choosing the Right Engine Oil

Imagine you’re an engine oil manufacturer. Every day, customers ask you which oil is best for their engines. Some have one-cylinder engines, others have multi-cylinder setups. Price, viscosity, and compatibility all matter—but helping them make the right choice isn’t just about knowing your products. It’s about **how you store and present that information**.

At first, it might seem simple. You could create a quick reference table:

| Oil Type      | Brand | Use                  | Price | Viscosity Grade |
| ------------- | ----- | -------------------- | ----- | --------------- |
| Primary oil   | A1X   | One-cylinder engines | 15    | 0W-20           |
| Secondary oil | B2Z   | Two-cylinder engines | 17    | 5W-30           |

Looks neat, right? But as your product line grows, so does the complexity. Adding new oils, updating prices, or including extra metadata like cylinder count or warranty quickly turns into a maintenance nightmare.

![Bottles of Pennzoil motor oil on a store shelf.](/images/blog/scalable-maintainable-technical-docs-with-yaml-large.webp)

### The XML temptation

Some teams start with **DITA reference XML**, thinking structure solves the problem:

```xml
<reference id="oil-types">
  <title>Oil types</title>
  <shortdesc>You will find below the recommended oil types.</shortdesc>
  <refbody>
    <section>
      <title>Primary oil</title>
      <ul>
        <li>Brand: A1X</li>
        <li>Use: One-cylinder engines</li>
        <li>Price: 15</li>
        <li>Viscosity grade: 0W-20</li>
      </ul>
    </section>
    <section>
      <title>Secondary oil</title>
      <ul>
        <li>Brand: B2Z</li>
        <li>Use: Two-cylinder engines</li>
        <li>Price: 17</li>
        <li>Viscosity grade: 5W-30</li>
      </ul>
    </section>
  </refbody>
</reference>
```

It seems neat at first. Each oil has a dedicated section. But the moment prices change, new products are added, or you want to track extra attributes, the XML becomes cumbersome.

| Issue                                      | Description                                                                                |
| ------------------------------------------ | ------------------------------------------------------------------------------------------ |
| **Hardcoded Values**                       | Every data point is embedded in XML. Updates require manual changes, which is error-prone. |
| **Mixing Data and Presentation**           | `<ul>` and `<li>` combine field names and values, making automated processing difficult.   |
| **Poor Scalability**                       | Adding oils or metadata requires repeating XML structures.                                 |
| **Lack of Unique Identifiers**             | Sections are distinguished by titles only, risking breakage in workflows if names change.  |
| **Limited Reusability**                    | Copying sections across documents increases the risk of inconsistencies.                   |
| **Ambiguous Values**                       | `<li>Price: 15</li>` lacks units or currency.                                              |
| **No Validation for Consistent Structure** | Missing fields reduce data quality over time.                                              |

Hardcoded XML works for tiny lists—but it quickly becomes brittle as content grows.

---

### Markdown tables: simple but limiting

Markdown tables are easier to read:

```markdown
| Oil Type      | Brand | Use                  | Price | Viscosity Grade |
| ------------- | ----- | -------------------- | ----- | --------------- |
| Primary oil   | A1X   | One-cylinder engines | 15    | 0W-20           |
| Secondary oil | B2Z   | Two-cylinder engines | 17    | 5W-30           |
```

They render nicely and are human-friendly—but they carry hidden maintainability problems:

| Issue                          | Description                                                                         |
| ------------------------------ | ----------------------------------------------------------------------------------- |
| **Hardcoded Data**             | Manual updates are required for any change, which is error-prone.                   |
| **Lack of Semantic Structure** | Field names and values are not machine-readable, making automation difficult.       |
| **Poor Scalability**           | Adding new oils or metadata requires editing the table structure.                   |
| **No Unique Identifiers**      | Rows are identified only by “Oil Type,” making programmatic referencing unreliable. |
| **Ambiguities**                | Values like `Price: 15` lack units, which can cause misinterpretation.              |
| **Limited Reusability**        | Tables are hard to reuse across multiple documents, creating redundancy.            |

Markdown is fine for static pages—but as your documentation grows, you need a better approach.

---

### Databases: flexible but costly

Databases offer structured storage and queries, but repeated queries can create performance issues:

| Issue                         | Description                                                      |
| ----------------------------- | ---------------------------------------------------------------- |
| **Performance Overhead**      | Each query consumes resources; repeated queries slow the system. |
| **Increased Network Traffic** | Multiple queries generate unnecessary load.                      |
| **Higher Costs**              | Cloud usage costs rise with frequent queries.                    |
| **Data Consistency Issues**   | Data changes between queries can produce inconsistent results.   |
| **Scalability Problems**      | Heavy query repetition strains the database.                     |
| **Redundant Computation**     | Expensive operations are repeated unnecessarily.                 |
| **Increased Latency**         | Users notice slower response times for each query.               |

Mitigation strategies like **caching, batching, materialized views, and optimized indexing** help—but they add complexity.

---

### YAML: readable, structured, and scalable

This is where **YAML** shines. It’s human-readable, hierarchical, and structured, making it ideal for documentation that needs to scale.

```yaml
id: oil-types
title: Oil types
shortdesc: Recommended oil types
properties:
  headers:
    type: Type
    value: Brand
    usage: Use
  rows:
    - type: Primary oil
      value: A1X
      usage: One-cylinder engines
    - type: Secondary oil
      value: B2Z
      usage: Two-cylinder engines
```

Rendered in Markdown, it produces a clean table:

| Oil type      | Oil brand | Use                  |
| ------------- | --------- | -------------------- |
| Primary oil   | A1X       | One-cylinder engines |
| Secondary oil | B2Z       | Two-cylinder engines |

### Benefits of YAML

| Feature                                      | Details                                                                              |
| -------------------------------------------- | ------------------------------------------------------------------------------------ |
| **Separation of Data and Presentation**      | Data can be reused in tables, lists, APIs, or UIs without touching formatting.       |
| **Structured and Predictable**               | Consistent schema reduces human error and simplifies automation.                     |
| **Easy to Extend**                           | Add new oils or metadata without redesigning the structure.                          |
| **Supports Automation**                      | Scripts or static site generators can consume YAML directly.                         |
| **Unique Identifiers**                       | Top-level `id` allows reliable referencing across documents.                         |
| **Improved Readability and Maintainability** | Keys are self-explanatory, easier to understand than inline XML or Markdown tables.  |
| **Scalable for Large Datasets**              | Works equally well for 5 or 500 rows; updates and validation remain straightforward. |

---

## Versatility

One of the key advantages of using structured data formats like YAML is **versatility**. The same dataset can be rendered in multiple ways—lists, tables, or even more complex layouts—without changing the source file.

For example, you can display your data as a **simple list**:

<blockquote>
<ToolsList />
</blockquote>

Or you can present it as a **styled two-column table**:

<blockquote>
<ToolsTable />
</blockquote>

If you need a richer display, you can even switch to a **five-column table on desktop (that automatically stacks into a single-column card view on mobile)**—all without editing the source YAML.

import Mermaid from '@/components/Mermaid.astro';

<Mermaid chart={`
flowchart LR
    %% Nodes
    B["YAML data"]
    F1["Title"]
    F2["Short<br/>description"]
    F3["Table<br/>header"]
    H["One table row<br/>per YAML entry"]

    %% Row values (documents) in one subgraph
    subgraph RowValues[ ]
      direction LR
      J["Primary<br/>oil"]
      K["A1X"]
      L["..."]
    end

    %% Row headers in one subgraph
    subgraph RowHeaders[ ]
      direction LR
      H1["Type"]
      H2["Brand"]
      H3["..."]
    end

    %% Flows with animated links
    B a1@--> F1
    B a2@--> F2
    B a3@--> F3
    B a4@--> H

    H a5@-.-> J
    H a6@-.-> K
    H a7@-.-> L

    F3 a8@--> H1
    F3 a9@--> H2
    F3 a10@--> H3

    %% Animation speeds
    a1@{ animation: slow }
    a2@{ animation: slow }
    a3@{ animation: slow }
    a4@{ animation: fast }
    a5@{ animation: slow }
    a6@{ animation: slow }
    a7@{ animation: slow }
    a8@{ animation: slow }
    a9@{ animation: slow }
    a10@{ animation: slow }

    %% Styling
    classDef topic fill:#fbe9e4,stroke:#df9277,stroke-width:2px,color:#5a2e23,font-weight:bold,rx:8,ry:8;
    classDef step fill:#f6d1c5,stroke:#d97d61,stroke-width:2px,color:#4a241a,font-weight:bold,rx:8,ry:8;
    classDef substep fill:#3498dc,stroke:#1f5a82,stroke-width:2px,color:#ffffff,font-weight:bold,rx:8,ry:8;
    classDef documents fill:#ebf0f1,stroke:#4c4c4c,stroke-width:2px,color:#000000,font-weight:bold,rx:8,ry:8;

    %% Apply classes
    class B topic;
    class F1,F2,F3 step;
    class H1,H2,H3 substep;
    class J,K,L documents;

    %% Link styles
    linkStyle default stroke:#d97d61,stroke-width:2px;
`} />
**Processing Oil Data: From YAML Import to Dynamic HTML Table**

<blockquote>
<ToolsTableFourCols />
</blockquote>

This flexibility allows your documentation to adapt to different contexts—whether it’s a quick reference list for users, a detailed table for technical readers, or a complex component in a UI. By separating content from presentation, you can maintain a single source of truth while offering multiple ways to consume the data.

---

### Growing with your YAML

Our **oil-types.yaml** started as a simple table but evolved into a **single source of truth**:

* Reusable DITA reference topics
* OpenAPI JSON endpoints
* UI components for apps

By enforcing **strong typing**—numbers for prices, integers for cylinder count—data stays consistent. A **central schema** ensures DRY (Don’t Repeat Yourself) principles and enables automated validation.

---

### The Takeaway

Documentation isn’t just about listing data. It’s about **making it maintainable, scalable, and reusable**. Markdown tables or hardcoded XML may work for small static lists, but as content grows, YAML provides the best balance: **human-readable, structured, and flexible**.

By treating your documentation as **data with a schema**, technical writers can bridge the gap between human-friendly docs and developer-friendly APIs—keeping both consistent and reducing errors.

---

<blockquote>
Learn more about [getting the benefits of DITA XML without its complexity](https://redaction-technique.org/blog/strong-information-typing-without-xml-overhead). Modern docs-as-code workflows let technical writers structure information using lightweight, open tools—no XML headaches required.
</blockquote>  
