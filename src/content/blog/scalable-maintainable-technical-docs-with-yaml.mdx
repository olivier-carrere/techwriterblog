---
draft: false
title: "Boost Documentation Efficiency: How YAML Outperforms XML, Markdown, and Databases"
snippet: "Streamline your docs with YAML: scalable, automated, and maintainable solutions for technical data."
image:
  src: "/images/blog/scalable-maintainable-technical-docs-with-yaml.webp"
  alt: "YAML table evolving into a structured schema for documentation and APIs"
publishDate: "2025-09-27 00:00"
category: "Blog"
author: "Olivier Carrère"
tags: [YAML, OpenAPI, Schema, Structured Data, Technical Writing, Content Reuse, Validation]
---

import ToolsList from '../../components/ToolsList.astro'
import ToolsTable from '../../components/ToolsTable.astro'
import ToolsTableFourCols from '../../components/ToolsTableFourCols.astro';
import yamlRaw from '../../data/oil-types.yaml?raw';

Imagine you're an engine oil manufacturer, tasked with helping customers choose the right product for their engines. Each oil you produce has a specific purpose—some work best in one-cylinder engines, others in multi-cylinder setups. Factors like price, viscosity, and engine compatibility play a critical role in a customer’s decision. The table below provides a clear comparison of a few key oil types, highlighting their intended use, cost, and viscosity grade, making it easier to guide customers toward the perfect choice.

But here’s a bigger question: how should you store the information about your oils? In a Markdown table? A database? A DITA reference XML topic? Or some other system entirely?

## DITA reference

Let's consider this DITA [reference](https://docs.oasis-open.org/dita/v1.2/os/spec/langref/reference.html) example.

```xml
<reference id="oil-types">
  <title>Oil types</title>
  <shortdesc>You will find below the recommended oil types.</shortdesc>
  <refbody>
    <section>
      <title>Primary oil</title>
      <ul>
        <li>Brand: A1X</li>
        <li>Use: One-cylinder engines</li>
        <li>Price: 15</li>
        <li>Viscosity grade: 0W-20</li>
      </ul>
    </section>
    <section>
      <title>Secondary oil</title>
      <ul>
        <li>Brand: B2Z</li>
        <li>Use: Two-cylinder engines</li>
        <li>Price: 17</li>
        <li>Viscosity grade: 5W-30</li>
      </ul>
    </section>
  </refbody>
</reference>
```

### Why Hardcoded XML Can Hurt Maintainability

When documenting technical data like recommended oil types, it might be tempting to simply hardcode information directly in XML. While this works for small, static lists, it introduces several **maintainability pitfalls** that can grow into serious headaches over time. Let’s break down the main issues.

| Issue                                      | Description                                                                                                                                                          |
|--------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Hardcoded Values**                       | Every piece of data is directly embedded in the XML. Manual updates are required if prices or types change, which is error-prone and does not scale.                 |
| **Mixing Data and Presentation**           | Using `<ul>` and `<li>` combines **field names** and **values** in a single line, making programmatic access difficult. Parsing text increases risk of errors.       |
| **Poor Scalability**                       | Adding new oil types requires repeating `@<section>` and `<ul>` structures. Adding metadata like supplier or warranty requires manual updates, making XML cumbersome. |
| **Lack of Unique Identifiers**             | Sections are distinguished only by `<title>`. Changes or duplicates in titles can break automated workflows.                                                         |
| **Limited Reusability**                    | Copy-pasting sections across documents requires multiple edits for updates, increasing risk of inconsistencies.                                                      |
| **Ambiguous Values**                       | Entries like `<li>Price: 15</li>` lack units or currency, which can cause confusion for automated systems.                                                           |
| **No Validation for Consistent Structure** | Fields like brand, price, or viscosity can be accidentally omitted, reducing data quality over time.                                                                 |

Hardcoding technical data in XML is fine for small, static lists, but as content grows, it becomes fragile, redundant, and difficult to manage. Better practices include separating data from presentation, using structured fields, and adding unique identifiers for programmatic access.

## Markdown Tables

Here’s how you could implement the same information in a **Markdown table**:

```markdown
| Oil Type      | Brand | Use                  | Price | Viscosity Grade |
| ------------- | ----- | -------------------- | ----- | --------------- |
| Primary oil   | A1X   | One-cylinder engines | 15    | 0W-20           |
| Secondary oil | B2Z   | Two-cylinder engines | 17    | 5W-30           |
```

### The Hidden Maintainability Challenges of Markdown Tables

Markdown tables are a popular choice for presenting structured data like recommended oil types. They are easy to read and render nicely in documentation. However, beneath the simplicity, they introduce several **maintainability issues** that technical writers and documentation teams should be aware of.

| Issue                          | Description                                                                                                                                                                                             |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Hardcoded Data**             | Every value—brand, price, use, and viscosity—is hardcoded in the table. Manual updates are required if values change, which is time-consuming and error-prone in large documents.                       |
| **Lack of Semantic Structure** | Markdown tables do not separate **field names** from **values** in a machine-readable way. Each row is just text, making automated processing, filtering, or transformation difficult.                  |
| **Poor Scalability**           | Adding new oil types requires manually inserting new rows. Adding metadata fields like supplier or warranty requires editing the table structure, which can break formatting and cause inconsistencies. |
| **No Unique Identifiers**      | Rows are distinguished only by the “Oil Type” column. If names change or are duplicated, there is no reliable way to reference or link entries programmatically.                                        |
| **Ambiguities**                | Values like `Price: 15` lack units or currency. Markdown does not enforce clarity or consistency, increasing the risk of misinterpretation.                                                             |
| **Limited Reusability**        | Tables are hard to reuse across multiple documents. Copying creates redundancy, and updates must be repeated wherever the table appears.                                                                |

While Markdown tables are visually straightforward, they are not ideal for long-term maintainability when documenting structured technical data. Separating data from presentation and using more structured formats can save time and reduce errors as documentation grows.

## Databases

Querying the same information repeatedly from a database can have several disadvantages, both in terms of performance and maintainability.

| Issue | Description |
|-------|-------------|
| **Performance Overhead** | Every query consumes database resources (CPU, memory, I/O). Repeated queries for the same data increase load, potentially slowing down the database and other applications. Can lead to longer response times, especially for complex queries or large datasets. |
| **Increased Network Traffic** | Each query requires a round-trip between your application and the database. Multiple queries for the same data generate unnecessary network traffic, which can be a bottleneck in distributed systems. |
| **Higher Costs** | For cloud-based databases, costs are often tied to usage (queries, data transfer, storage). Repeated queries for the same data can increase operational costs. |
| **Data Consistency Issues** | If the underlying data changes between queries, repeated requests might return inconsistent results. This can be problematic for caching strategies or when calculations depend on stable snapshots. |
| **Scalability Problems** | High query repetition can strain the database, making it harder to scale under heavy load. The more users or services that repeatedly query the same data, the more pressure on your system. |
| **Redundant Computation** | Complex queries often require the database to recompute joins, aggregations, or indexes every time. This wastes computational resources if the results could otherwise be cached. |
| **Increased Latency for Users** | Users experience slower response times when every action triggers a fresh database query. Especially noticeable in web apps or APIs that make multiple queries per page load. |

### Mitigation Strategies

| Mitigation Strategy | Description |
|--------------------|-------------|
| **Caching** | Store frequently accessed data in memory (e.g., Redis, Memcached) to avoid repeated queries. |
| **Batching** | Fetch all needed data in a single query instead of multiple small queries. |
| **Materialized Views** | Precompute expensive queries and store results in the database. |
| **Optimized Indexing** | Ensure queries use indexes efficiently to reduce execution time. |

## The Case for Switching to YAML

Switching to YAML makes your docs site far more scalable and maintainable. YAML’s structured, hierarchical format keeps data organized, easy to update, and ready for dynamic rendering—no more messy tables or broken formatting. It’s readable, comment-friendly, and built for automation, so your content grows with your site, not your headaches.

This renders your YAML content automatically as a list.

<blockquote>
<ToolsList />
</blockquote>

Your YAML content now renders automatically as a styled table.

<blockquote>
<ToolsTable />
</blockquote>

You can switch to a five-column table without editing the source file.

<blockquote>
<ToolsTableFourCols />
</blockquote>

---

### YAML structures

YAML structures improve maintainability by providing clear structure, separation of content from display, scalability, automation support, and readability. It reduces human error, simplifies updates, and allows the data to be reused across multiple outputs effortlessly.

| Feature                                      | Details                                                                                                                                                                                                                                                      |
| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Separation of Data from Presentation**     | The YAML defines **data independently** of how it will be displayed (table, list, or API). The `headers` define the columns, and `rows` define the content. This separation allows changing table rendering or styling without touching the underlying data. |
| **Structured and Predictable Format**        | Each row follows a consistent schema: `type`, `value`, `description`. Ensures **uniformity** across entries and reduces human error. Tools or scripts can easily parse this structured format, unlike unstructured Markdown or plain XML lists.              |
| **Easy to Extend**                           | Adding a new oil type or extra metadata (e.g., `price`, `viscosity`) is straightforward. No need to redesign tables or manually align columns.                                                                                                               |
| **Supports Automation**                      | Structured data can be consumed by scripts, static site generators, or APIs. Tables, charts, or dropdowns can be **automatically generated**, and updates propagate instantly.                                                                               |
| **Unique Identifiers for Easy Reference**    | Top-level `id: oil-types` allows unique referencing across documents or systems, making integration and cross-referencing **more reliable** than using row titles alone.                                                                                     |
| **Improved Readability and Maintainability** | Human-readable keys (`type`, `value`, `description`) make it **easy for writers and developers to understand** the dataset. Clearer than unstructured tables or inline XML lists.                                                                            |
| **Scalable for Large Datasets**              | Works for 5 rows or 500, scaling without increasing complexity. Each row is independent, making bulk updates or automated validation straightforward.                                                                                                        |

### Managing a growing data table

The **oil-types.yaml** file began as a **simple data table** for documentation. Over time, it became the single source of truth for:

* Reusable product tables in DITA and Markdown docs
* An OpenAPI endpoint serving JSON
* Future integrations with client-side apps

The first version was minimal, meant only for static rendering in docs:

```yaml
id: oil-types
title: Oil types
shortdesc: You will find below the recommended oil types.

properties:
  headers:
    type: Oil type
    value: Oil brand
    description: Appropriate use
  rows:
    - type: Primary oil
      value: A1X
      description: One-cylinder engines
    - type: Secondary oil
      value: B2Z
      description: Two-cylinder engines
```

Rendered in Markdown, it looked like a standard table:

| Oil type      | Oil brand | Appropriate use      |
| ------------- | --------- | -------------------- |
| Primary oil   | A1X       | One-cylinder engines |
| Secondary oil | B2Z       | Two-cylinder engines |

At this stage, the YAML was little more than a **Markdown table in disguise**. That works fine for a static page, but Markdown tables quickly show their limits:

* **Locked to one format**—fine for human readers, useless for APIs or apps
* **Manual upkeep**—duplicate copies across docs risk inconsistency
* **No typing or validation**—strings, numbers, and labels can drift unnoticed

Even so, the YAML hinted at something more powerful: a **single source of truth**. Once enriched with structure and typing, the same file could generate:

* Markdown tables for docs
* OpenAPI endpoints serving JSON
* SEO-friendly HTML components
* Data feeds for apps

### Standardizing labels

To align with existing **DITA reference tables**, I unified the column names:

```diff
-    type: Oil type
-    value: Oil brand
-    description: Appropriate use
+    type: Type
+    value: Brand
+    description: Use
```

This small change simplified **content reuse** and avoided confusion across formats.

---

### Adding new columns

Next, the table expanded to include **price** and **viscosity grade**—turning it into a richer product spec.

```diff
   rows:
     - type: Primary oil
-      value: A1X
-      description: One-cylinder engines
+      name: A1X
+      price: 15
+      usage: One-cylinder engines
+      viscosity_grade: 0W-20
```

---

### Enforcing strong typing

When serving YAML through an API, type safety became essential. I switched to explicit YAML tags:

```diff
-id: oil-types
-title: Oil types
-shortdesc: You will find below the recommended oil types.
+id: !!str oil-types
+title: !!str Oil types
+shortdesc: !!str You will find below the recommended oil types.

   rows:
-    - type: Primary oil
-      name: A1X
-      price: 15
-      usage: One-cylinder engines
-      viscosity_grade: 0W-20
+    - type: !!str Primary oil
+      name: !!str A1X
+      price: !!float 15.0
+      cylinders: !!int 1
+      viscosity_grade: !!str 0W-20
```

This ensured that values like **price** and **cylinders** were validated as numbers, not strings.

---

### Centralizing the schema

To avoid repeating type annotations, I introduced a **row_schema**:

```diff
   properties:
     headers:
       type: Type
       name: Brand
       usage: Use
+
+    row_schema:
+      type: str
+      name: str
+      price: float
+      cylinders: int
+      viscosity_grade: str
```

Centralizing the schema kept the YAML **DRY** (Don’t Repeat Yourself) and enabled automated validation.

---

## Looking ahead

We now have a **single YAML source** that feeds:

* DITA reference topics
* OpenAPI JSON endpoints
* Potential UI components

Next steps include:

* **Automated validation pipelines** in CI/CD
* **Versioned schemas** for backward compatibility
* **Interactive docs** that query YAML live

By treating documentation tables as **data with a schema**, technical writers can bridge the gap between human-friendly docs and developer-friendly APIs—keeping both consistent and easy to maintain.

---

<blockquote>
Learn more about gaining the [benefits of DITA XML without its complexity](https://redaction-technique.org/blog/strong-information-typing-without-xml-overhead). Using Markdown and modern docs-as-code workflows, technical writers can apply structured information typing—tasks, concepts, and references—through lightweight, open tools.
</blockquote>
