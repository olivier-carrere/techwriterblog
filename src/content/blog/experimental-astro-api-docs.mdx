---
draft: false
title: "Distribute API Reference from YAML Across Docs, and Apps"
snippet: "Learn how one YAML file can serve as a single source of truth for APIs, powering docs, HTML documentation, and even mobile apps."
image:
  src: "/images/blog/experimental-astro-api-docs.webp"
  alt: "Astro API Documentation Illustration"
publishDate: "2025-09-24"
category: "Development"
tags: ["astro", "api", "openapi", "yaml", "documentation"]
---

I‚Äôve been experimenting with **self-documenting APIs in Astro**, and you can now [**browse the live API documentation**](https://redaction-technique.org/docs).

![Display the same information on a mobile app and on a web page from the same source.](/images/blog/experimental-astro-api-docs-mobile.webp)

The real magic is that **everything comes from a single YAML file**.

By exposing structured reference information through an API generated from YAML, you can **reuse the same source of truth** across multiple contexts:

* Interactive API documentation
* Static HTML doc pages
* Mobile and desktop applications
* Build-time Astro components for SEO-friendly rendering

## One YAML File, Many Outputs

By keeping all reference information in **a single YAML file**, you gain a powerful distribution workflow.
From this one source of truth, the data can flow into **interactive API documentation**, **SEO-friendly HTML pages**, or be accessed directly via **API calls**.

![Display the same information on a mobile app and on a web page from the same source.](/images/blog/experimental-astro-api-docs-large.webp)

The diagram below shows how the same YAML powers multiple outputs without duplication or extra maintenance:

import Mermaid from '@/components/Mermaid.astro';

<Mermaid chart={`
graph TD
A["üìÑ YAML Source File"]:::topic --> B["üìò API Docs<br/>(OpenAPI schema)"]:::step
A --> C["üåê Static HTML Docs<br/>(Astro build-time)"]:::step
A a1@--> D["‚ö° API Queries<br/>(fetch / curl)"]:::step
B -->|Interactive browsing| B1["üñ•Ô∏è Web UI"]:::substep
C -->|SEO-friendly pages| C1["üìë Tables, Lists"]:::substep
D a2@-->|Live API calls| D1["üì¶ JSON Responses"]:::substep
D a3@-->|Consumed by clients| D2["üì± Mobile App"]:::substep

a1@{ animation: slow }
a2@{ animation: slow }
a3@{ animation: slow }

classDef topic fill:#fbe9e4,stroke:#df9277,stroke-width:2px,color:#5a2e23,font-weight:bold,rx:8,ry:8;
classDef step fill:#f6d1c5,stroke:#d97d61,stroke-width:2px,color:#4a241a,font-weight:bold,rx:8,ry:8;
classDef substep fill:#efb9a6,stroke:#c96a52,stroke-width:2px,color:#3d1d15,font-weight:bold,rx:8,ry:8;
`} />

## Querying the API in Practice

You can query the API directly with JavaScript or from your terminal.

### Using fetch (JavaScript)

```ts
// Fetch all oil types
fetch("https://redaction-technique.org/api/oil-types")
  .then(res => res.json())
  .then(data => {
    console.log("All oil types:", data);
  });
```

### Using cURL (terminal)

```bash
# Get all oil types
curl https://redaction-technique.org/api/oil-types
```

## Example JSON Output

Here‚Äôs what you‚Äôll see when calling the API:

### GET /api/oil-types

```json
{
  "id": "oil-types",
  "title": "Oil types",
  "shortdesc": "You will find below the recommended oil types.",
  "properties": {
    "headers": {
      "type": "Type",
      "value": "Brand",
      "description": "Use"
    },
    "rows": [
      {
        "type": "Primary oil",
        "value": "A1X",
        "description": "One-cylinder engines"
      },
      {
        "type": "Secondary oil",
        "value": "B2Z",
        "description": "Two-cylinder engines"
      }
    ]
  }
}
```

## Why YAML as the Source of Truth?

Instead of relying on a static JSON schema, the API specification is generated **directly from YAML**.

This approach ensures:

* **One source of truth** across APIs, docs, and apps
* **Automatic updates**‚Äîchange the YAML, and all media refresh accordingly
* **Lower maintenance costs** by avoiding duplicated schemas or outdated docs

By centralizing reference information in YAML, you don‚Äôt just build an API‚Äîyou build a **distribution engine for consistent, reusable documentation across every medium**.

<blockquote>
As explained in [Strong Information Typing Without XML Overhead](https://redaction-technique.org/blog/strong-information-typing-without-xml-overhead), the same YAML file can also be consumed **at build time in Astro**.  
This lets you generate **static tables, lists, or components**‚Äîkeeping pages fast, SEO-friendly, and always consistent with the live API.
</blockquote>
