---
draft: false
title: "Distribute API Reference from YAML Across Docs, Apps, and Swagger"
snippet: "Learn how one YAML file can serve as a single source of truth for APIs, powering Swagger docs, HTML documentation, and even mobile apps."
image:
  src: "/images/blog/experimental-astro-api-docs.webp"
  alt: "Astro API Documentation Illustration"
publishDate: "2025-09-24"
category: "Development"
tags: ["astro", "api", "swagger", "openapi", "yaml", "documentation"]
---

I’ve been experimenting with **self-documenting APIs in Astro**, and you can now [**browse the live Swagger-powered documentation**](https://redaction-technique.org/docs).

<iframe
  title="Redaction Technique Documentation"
  src="https://redaction-technique.org/docs"
  width="100%"
  height="500"
  style={{ border: 'none' }}
  loading="lazy"
></iframe>

This Swagger UI is powered by a dynamic OpenAPI schema—but the real magic is that **everything comes from a single YAML file**.  

By exposing structured reference information through an API generated from YAML, you can **reuse the same source of truth** across multiple contexts:  

- Swagger interactive documentation  
- Static HTML doc pages  
- Mobile and desktop applications  
- Build-time Astro components for SEO-friendly rendering  

## One YAML File, Many Outputs

The API serves [structured content generated from a YAML source file](https://redaction-technique.org/api/oil-types).  

Here’s an example of the underlying YAML:

```yaml
id: oil-types
title: Oil types
shortdesc: You will find below the recommended oil types.
properties:
  headers:
    type: Type
    value: Brand
    description: Use
  rows:
    - type: Primary oil
      value: A1X
      description: One-cylinder engines
    - type: Secondary oil
      value: B2Z
      description: Two-cylinder engines
````

This single file transforms into an **OpenAPI schema**, making it possible for Swagger to display the content interactively—while the same data is also consumable in apps, docs, or build-time pipelines.

## Querying the API in Practice

You can query the API directly with JavaScript or from your terminal.

### Using fetch (JavaScript)

```ts
// Fetch all oil types
fetch("https://redaction-technique.org/api/oil-types")
  .then(res => res.json())
  .then(data => {
    console.log("All oil types:", data);
  });
```

### Using cURL (terminal)

```bash
# Get all oil types
curl https://redaction-technique.org/api/oil-types
```

## Example JSON Output

Here’s what you’ll see when calling the API:

### GET /api/oil-types

```json
{
  "id": "oil-types",
  "title": "Oil types",
  "shortdesc": "You will find below the recommended oil types.",
  "properties": {
    "headers": {
      "type": "Type",
      "value": "Brand",
      "description": "Use"
    },
    "rows": [
      {
        "type": "Primary oil",
        "value": "A1X",
        "description": "One-cylinder engines"
      },
      {
        "type": "Secondary oil",
        "value": "B2Z",
        "description": "Two-cylinder engines"
      }
    ]
  }
}
```

<blockquote>
As explained in [Strong Information Typing Without XML Overhead](https://redaction-technique.org/blog/strong-information-typing-without-xml-overhead), the same YAML file can also be consumed **at build time in Astro**.  
This lets you generate **static tables, lists, or components**—keeping pages fast, SEO-friendly, and always consistent with the live API.
</blockquote>

## Why YAML as the Source of Truth?

Instead of relying on a static `openapi.json`, the schema is generated **directly from YAML**.

This approach ensures:

* **One source of truth** across APIs, docs, and apps
* **Automatic updates**—change the YAML, and all media refresh accordingly
* **Lower maintenance costs** by avoiding duplicated schemas or outdated docs

By centralizing reference information in YAML, you don’t just build an API—you build a **distribution engine for consistent, reusable documentation across every medium**.
