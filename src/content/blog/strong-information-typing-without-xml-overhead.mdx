---
draft: false
title: "Strong information typing without the XML overhead"
snippet: "You don’t need the complexity of DITA XML to benefit from its discipline. With Markdown and modern docs-as-code workflows, technical writers can apply strong information typing—tasks, concepts, and references—using lightweight, open tools."
image: {
    src: "/images/blog/strong-information-typing-without-xml-overhead.webp",
    alt: "Illustration of a feather symbolizing Markdown as a lightweight alternative to DITA XML"
}
publishDate: "2025-09-17 11:39"
category: "Blog"
author: "Olivier Carrère"
tags: ["DITA", "Markdown", "Information Typing", "Content Model", "Docs-as-Code"]
---

import ToolsList from '../../components/ToolsList.astro'
import ToolsTable from '../../components/ToolsTable.astro'

If you’ve spent years working daily with the DITA XML platform, you know that DITA is more than a markup language. It’s a way of thinking about information design. Writing tasks, concepts, and references in DITA teaches you to break down content into consistent building blocks, which makes documentation easier to navigate, maintain, and reuse.

![XML overhead: A cargo ship](/images/blog/strong-information-typing-without-xml-overhead-large.webp)


The good news is: you don’t need an XML editor or a DITA-OT pipeline to keep practicing those principles. With Markdown and modern docs-as-code workflows, you can implement DITA’s information typing philosophy in a lightweight, flexible way.

## The DITA mindset

DITA trains you to ask:

* **Is this a task?** → A sequence of steps that helps the reader achieve a goal.
* **Is this a concept?** → A piece of explanatory content that builds understanding.
* **Is this a reference?** → A structured lookup table or fact sheet.

Once you’ve internalized this mindset, it becomes natural to apply it even outside XML. Markdown pages, Git-based workflows, and static site generators all benefit when you keep these categories clear.

## DITA-like task pages

DITA task topics have strict rules: short context, prerequisites, ordered steps, results. The official [OASIS example](https://docs.oasis-open.org/dita/v1.2/os/spec/langref/step.html) is as follows:

```xml
<task id="sqlj">
<title>Creating an SQLJ file</title>
<taskbody>
<context>Once you have set up SQLJ, you need to create a new SQLJ file.</context>
<steps>
<step>
 <cmd>Select <menucascade><uicontrol>File</uicontrol>
 <uicontrol>New</uicontrol></menucascade>.</cmd>
 <info>New files are created with default values based on a standard template.</info>
</step>
</steps>
</taskbody>
</task>
```

import Mermaid from '@/components/Mermaid.astro';

<Mermaid chart={`
graph LR
  %% Nodes
  T[Task Topic]
  T1[Title]
  T2[Short Description]
  T3[Prerequisites]
  T4[Steps]
  T5[Result / Output]
  T6[Example / Notes]

  %% Nested steps
  S1[Step 1]
  S1a[Command]
  S1b[Additional info]
  S1c[Step result]
  S2[Step 2]
  S2a[Command]
  S2b[Additional info]
  S2c[Step result]

  %% Structure
  T --> T1
  T --> T2
  T --> T3
  T --> T4
  T --> T5
  T --> T6

  T4 --> S1
  T4 --> S2
  S1 --> S1a
  S1 --> S1b
  S1 --> S1c
  S2 --> S2a
  S2 --> S2b
  S2 --> S2c

  %% Styling
  classDef topic fill:#fbe9e4,stroke:#df9277,stroke-width:2px,color:#5a2e23,font-weight:bold,rx:8,ry:8;
  classDef step fill:#f6d1c5,stroke:#d97d61,stroke-width:2px,color:#4a241a,font-weight:bold,rx:8,ry:8;
  classDef substep fill:#efb9a6,stroke:#c96a52,stroke-width:2px,color:#3d1d15,font-weight:bold,rx:8,ry:8;

  class T topic
  class T1,T2,T3,T4,T5,T6 step
  class S1,S1a,S1b,S1c,S2,S2a,S2b,S2c substep

  linkStyle default stroke:#df9277,stroke-width:2px;
`} />
**Hierarchy of Elements in a DITA Task Topic (Steps, Commands, Information, and Metadata)**


You can recreate this in Markdown easily:

```markdown
# Creating an SQLJ file

Once you have set up SQLJ, you need to create a new SQLJ file.

1. Select **File** > **New**

   New files are created with default values based on a standard template.
```

This keeps the procedural content focused and predictable, just like in DITA.

## DITA-like concept pages

Concepts explain “what” and “why” rather than “how.” The official [OASIS example](https://docs.oasis-open.org/dita/v1.2/os/spec/langref/concept.html) is as follows:

```xml
<concept id="concept">
 <title>Introduction to Bird Calling</title>
 <shortdesc>If you wish to attract more birds to your Acme Bird Feeder,
learn the art of bird calling. Bird calling is an efficient way
to alert more birds to the presence of your bird feeder.</shortdesc>
 <conbody>
   <p>Bird calling requires learning:</p>
   <ul>
    <li>Popular and classical bird songs</li>
    <li>How to whistle like a bird</li>
   </ul>
 </conbody>
</concept>
```

In Markdown, you can still signal that you’re writing a concept by structuring around definition and explanation.

```markdown
# Introduction to Bird Calling

If you wish to attract more birds to your Acme Bird Feeder, learn the art of
bird calling. Bird calling is an efficient way to alert more birds to the
presence of your bird feeder.

Bird calling requires learning:

- Popular and classical bird songs
- How to whistle like a bird
```

The structure shows it’s an explanatory page, not a step-by-step guide.

## DITA-like reference pages

References benefit from structured tables and lists.

Let's consider this DITA [reference](https://docs.oasis-open.org/dita/v1.2/os/spec/langref/reference.html) example:

```xml
<reference id="oil-types">
  <title>Oil types</title>
  <shortdesc>You will find below the recommended oil types.</shortdesc>
  <refbody>
    <section>
      <title>Primary oil</title>
      <ul>
        <li>Brand: A1X</li>
        <li>Use: One-cylinder engines</li>
      </ul>
    </section>
    <section>
      <title>Secondary oil</title>
      <ul>
        <li>Brand: B2Z</li>
        <li>Use: Two-cylinder engines</li>
      </ul>
    </section>
  </refbody>
</reference>
```

Markdown supports tables and lists:

```markdown
# Oil types
You will find below the recommended oil types.
- **Primary oil**
  - Brand: A1X
  - Use: One-cylinder engines
- **Secondary oil**
  - Brand: B2Z
  - Use: Two-cylinder engines
```

This mirrors a DITA reference topic: concise and easy to scan.

## YAML: Ideal for scalable and maintainable reference pages

Switching from Markdown tables to YAML makes your docs site far more scalable and maintainable. YAML’s structured, hierarchical format keeps data organized, easy to update, and ready for dynamic rendering—no more messy tables or broken formatting. It’s readable, comment-friendly, and built for automation, so your content grows with your site, not your headaches.

1. **Create the YAML file**
   Create a file at **src/data/oil-types.yaml** with the following content:

   ```yaml
   id: oil-types
   title: Oil types
   shortdesc: You will find below the recommended oil types.
   properties:
     headers:
       type: Type
       value: Brand
       description: Use
     rows:
       - type: Primary oil
         value: A1X
         description: One-cylinder engines
       - type: Secondary oil
         value: B2Z
         description: Two-cylinder engines
   ```

2. **Create the Astro component**
   Create a file at **src/components/ToolsList.astro** with the following content:

   ```javascript
   ---
   import data from "../data/oil-types.yaml";
   const rows = data.properties.rows;
   ---
   <h3>{data.title}</h3>
   <p>{data.shortdesc}</p>
   <ul>
     {rows.map(row => (
       <li>
         <strong>{row.type}</strong>
         <ul>
           <li>Brand: {row.value}</li>
           <li>Use: {row.description}</li>
         </ul>
       </li>
     ))}
   </ul>
   ```

3. **Insert the component in your MDX file**
   Add the following snippet to your **.mdx** file:

   ```html
   import ToolsList from '../../components/ToolsList.astro'
   <ToolsList />
   ```

   This renders your YAML content automatically as a list:
   
   <ToolsList />

4. **(Optional) Display the content in a table**
   If you prefer a table format, modify **ToolsList.astro** as follows:

   ```javascript
   ---
   import data from "../data/oil-types.yaml";
   const headers = data.properties.headers;
   const rows = data.properties.rows;
   ---
   <h3 style="color: #2c3e50;">{data.title}</h3>
   <p>{data.shortdesc}</p>
   <table style="border-collapse: collapse; width: 100%;">
     <thead style="background-color: #3498db; color: white;">
       <tr>
         <th style="padding: 8px; border: 1px solid #ddd;">{headers.type}</th>
         <th style="padding: 8px; border: 1px solid #ddd;">{headers.value}</th>
         <th style="padding: 8px; border: 1px solid #ddd;">{headers.description}</th>
       </tr>
     </thead>
     <tbody>
       {rows.map((row, index) => (
         <tr style={`background-color: ${index % 2 === 0 ? "#ecf0f1" : "#ffffff"};`}>
           <td style="padding: 8px; border: 1px solid #ddd;">{row.type}</td>
           <td style="padding: 8px; border: 1px solid #ddd;">{row.value}</td>
           <td style="padding: 8px; border: 1px solid #ddd;">{row.description}</td>
         </tr>
       ))}
     </tbody>
   </table>
   ```

   Your YAML content now renders automatically as a styled table:

   <ToolsTable />

## Why this matters

DITA XML can feel heavy to implement in modern docs pipelines. But the discipline you develop with years of daily practice doesn’t vanish when you move to Markdown. Instead, it becomes a superpower.

By bringing DITA’s principles into lightweight environments, you:

* Keep content modular and reusable.
* Reduce ambiguity for readers.
* Simplify onboarding for new writers.
* Make your documentation friendlier to automation and AI-assisted tools.

DITA taught us to think in types, not just topics. Markdown lets us practice that thinking with less overhead, using tools that integrate smoothly into today’s development workflows.

If you’ve worked in DITA for years, don’t see that experience as “outdated.” It’s the foundation for building smarter, cleaner, and more maintainable docs-as-code content today.
